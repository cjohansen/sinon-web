<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Sinon.JS - Documentation</title>
    <link rel="stylesheet" type="text/css" href="/design/css/sinon.min.css?7">
  </head>
  <body>
    <h1><a href="../">Sinon.JS</a> Documentation</h1>
    <ul class="nav">
      <li><a href="#spies">Spies</a></li>
      <li><a href="#stubs">Stubs</a></li>
      <li><a href="#mocks">Mocks</a></li>
      <li><a href="#clock">Fake timers</a></li>
      <li><a href="#server">Fake <code>XHR</code> and server</a></li>
      <li><a href="#assertions">Assertions</a></li>
      <li><a href="#matchers">Matchers</a></li>
      <li><a href="#sandbox">Sandboxing</a></li>
      <li><a href="#utils">Utils</a></li>
    </ul>
    <p>
      This page contains the entire Sinon.JS API documentation along with brief
      introductions to the concepts Sinon implements. Please ask questions on
      <a href="http://groups.google.com/group/sinonjs">the mailing list</a> if
      you're stuck. I also really appreciate suggestions to improve the
      documentation so Sinon.JS is easier to work with. Get in touch!
    </p>
    <div class="section" id="spies">
      <h2>Test spies <a class="api" href="#spies-api">API reference</a></h2>
      <ul class="nav">
        <li><a href="#sinonspy">sinon.spy()</a></li>
        <li><a href="#spies-api">spy API</a></li>
        <li><a href="#spycall">spy call API</a></li>
      </ul>
      <h3>What is a test spy?</h3>
      <p>
        A test spy is a function that records arguments, return value, the value
        of <code>this</code> and exception thrown (if any) for all its calls. A
        test spy can be an anonymous function or it can wrap an existing
        function.
      </p>
      <h3>When to use spies?</h3>
      <p>
        Test spies are useful to test both callbacks and how certain
        functions/methods are used throughout the system under test. The
        following simplified example shows how to use spies to test how a
        function handles a callback:
      </p>
      <pre class="sh_javascript"><code>"test should call subscribers on publish": function () {
    var callback = sinon.spy();
    PubSub.subscribe("message", callback);

    PubSub.publishSync("message");

    assertTrue(callback.called);
}</code></pre>
      <h3>Spying on existing methods</h3>
      <p>
        <code>sinon.spy</code> can also spy on existing functions. When doing
        so, the original function will behave just as normal (including when
        used as a constructor) but you will have access to data about all
        calls. The following is a slightly contrived example:
      </p>
      <pre class="sh_javascript"><code>{
    setUp: function () {
        sinon.spy(jQuery, "ajax");
    },

    tearDown: function () {
        jQuery.ajax.restore(); // Unwraps the spy
    },

    "test should inspect jQuery.getJSON's usage of jQuery.ajax": function () {
        jQuery.getJSON("/some/resource");

        assert(jQuery.ajax.calledOnce);
        assertEquals("/some/resource", jQuery.ajax.getCall(0).args[0].url);
        assertEquals("json", jQuery.ajax.getCall(0).args[0].dataType);
    }
}</code></pre>
      <h3 id="sinonspy">Creating spies: <code>sinon.spy()</code></h3>
      <dl>
        <dt><code>var spy = sinon.spy();</code></dt>
        <dd>
          Creates an anonymous function that records arguments, <code>this</code> value,
          exceptions and return values for all calls.
        </dd>
        <dt><code>var spy = sinon.spy(myFunc);</code></dt>
        <dd>Spies on the provided function</dd>
        <dt><code>var spy = sinon.spy(object, "method");</code></dt>
        <dd>
          Creates a <a href="#spyprops">spy</a> for <code>object.method</code>
          and replaces the original method with the spy. The spy acts exactly
          like the original method in all cases.  The original method can be
          restored by calling <code>object.method.restore()</code>.  The
          returned spy is the function object which replaced the original
          method. <code>spy === object.method</code>.
        </dd>
      </dl>
      <h3 id="spyprops">Spy API</h3>
      <p>
        Spies provide a rich interface to inspect their usage. The above
        examples showed the <code>calledOnce</code> boolean property as well as
        the <code>getCall</code> method and the returned
        object's <code>args</code> property. There are three ways of inspecting
        call data.
      </p>
      <p>
        The preferred approach is to use the spy's <code>calledWith</code>
        method (and friends) because it keeps your test from being too specific
        about which call did what and so on. It will return <code>true</code> if
        the spy was ever called with the provided arguments.
      </p>
      <pre class="sh_javascript"><code>"test should call subscribers with message as first argument" : function () {
    var message = getUniqueString();
    var spy = sinon.spy();

    PubSub.subscribe(message, spy);
    PubSub.publishSync(message, "some payload");

    assert(spy.calledWith(message));
}</code></pre>
      <p>
        If you want to be specific, you can directly check the first argument of
        the first call. There are two ways of achieving this:
      </p>
      <pre class="sh_javascript"><code>"test should call subscribers with message as first argument" : function () {
    var message = getUniqueString();
    var spy = sinon.spy();

    PubSub.subscribe(message, spy);
    PubSub.publishSync(message, "some payload");

    assertEquals(message, spy.args[0][0]);
}</code></pre>
      <pre class="sh_javascript"><code>"test should call subscribers with message as first argument" : function () {
    var message = getUniqueString();
    var spy = sinon.spy();

    PubSub.subscribe(message, spy);
    PubSub.publishSync(message, "some payload");

    assertEquals(message, spy.getCall(0).args[0]);
}</code></pre>
      <p>
        The first example uses the two-dimensional <code>args</code> array
        directly on the spy, while the second example fetches the first call
        object and then accesses it's <code>args</code> array. Which one to use
        is a matter of preference, but the recommended approach is going with
        <code>spy.calledWith(arg1, arg2, ...)</code> unless there's a need to
        make the tests highly specific.
      </p>
      <h3 id="spies-api">Spy API</h3>
      <p>
        Spy objects are objects returned from <code>sinon.spy()</code>. When
        spying on existing methods with <code>sinon.spy(object, method)</code>,
        the following properties and methods are also available
        on <code>object.method</code>.
      </p>
      <dl>
        <dt>spy.withArgs(arg1[, arg2, ...]);</dt>
        <dd>
          Creates a spy that only records calls when the received arguments
          matche those passed to <code>withArgs</code>. This is useful to be
          more expressive in your assertions, where you can access the spy with
          the same call:
          <pre class="sh_javascript"><code>"test should call method once with each argument": function () {
    var object = { method: function () {} };
    var spy = sinon.spy(object, "method");
    spy.withArgs(42);
    spy.withArgs(1);

    object.method(42);
    object.method(1);

    assert(spy.withArgs(42).calledOnce);
    assert(spy.withArgs(1).calledOnce);
}</code></pre>
        </dd>
        <dt><code>spy.callCount</code></dt>
        <dd>The number of recorded calls.</dd>
        <dt><code>spy.called</code></dt>
        <dd><code>true</code> if the spy was called at least once</dd>
        <dt><code>spy.calledOnce</code></dt>
        <dd><code>true</code> if spy was called exactly once</dd>
        <dt><code>spy.calledTwice</code></dt>
        <dd><code>true</code> if the spy was called exactly twice</dd>
        <dt><code>spy.calledThrice</code></dt>
        <dd><code>true</code> if the spy was called exactly thrice</dd>
        <dt><code>spy.firstCall</code></dt>
        <dd>The first call</dd>
        <dt><code>spy.secondCall</code></dt>
        <dd>The second call</dd>
        <dt><code>spy.thirdCall</code></dt>
        <dd>The third call</dd>
        <dt><code>spy.lastCall</code></dt>
        <dd>The last call</dd>
        <dt><code>spy.calledBefore(anotherSpy);</code></dt>
        <dd>Returns <code>true</code> if the spy was called before <code>anotherSpy</code></dd>
        <dt><code>spy.calledAfter(anotherSpy);</code></dt>
        <dd>Returns <code>true</code> if the spy was called after <code>anotherSpy</code></dd>
        <dt><code>spy.calledOn(obj);</code></dt>
        <dd>
          Returns <code>true</code> if the spy was called at least once with <code>obj</code>
          as <code>this</code>.
        </dd>
        <dt><code>spy.alwaysCalledOn(obj);</code></dt>
        <dd>
          Returns <code>true</code> if the spy was always called with <code>obj</code>
          as <code>this</code>.
        </dd>
        <dt><code>spy.calledWith(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if spy was called at least once with the provided
          arguments. Can be used for partial matching, Sinon only checks the provided
          arguments against actual arguments, so a call that received the provided arguments
          (in the same spots) and possibly others as well will return <code>true</code>.
        </dd>
        <dt><code>spy.alwaysCalledWith(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if spy was always called with the provided arguments
          (and possibly others).
        </dd>
        <dt><code>spy.calledWithExactly(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if spy was called at least once with the provided arguments
          and no others.
        </dd>
        <dt><code>spy.alwaysCalledWithExactly(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if spy was always called with the exact provided arguments.
        </dd>
        <dt><code>spy.calledWithMatch(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if spy was called with matching arguments
          (and possibly others). This behaves the same as
          <code>spy.calledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.
        </dd>
        <dt><code>spy.alwaysCalledWithMatch(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if spy was always called with matching arguments
          (and possibly others). This behaves the same as
          <code>spy.alwaysCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.
        </dd>
        <dt><code>spy.calledWithNew();</code></dt>
        <dd>
          Returns <code>true</code> if spy/stub was called the <code>new</code>
          operator. Beware that this is inferred based on the value of
          the <code>this</code> object and the spy
          function's <code>prototype</code>, so it may give false positives if
          you actively return the right kind of object.
        </dd>
        <dt><code>spy.notCalledWith(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if the spy/stub was called at least once
          with arguments not matching the provided ones.
        </dd>
        <dt><code>spy.neverCalledWith(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if the spy/stub was never called with
          the provided arguments.
        </dd>
        <dt><code>spy.notCalledWithMatch(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if the spy/stub was called at least once
          with arguments not matching the provided ones. This behaves the same as
          <code>spy.notCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.
        </dd>
        <dt><code>spy.neverCalledWithMatch(arg1, arg2, ...);</code></dt>
        <dd>
          Returns <code>true</code> if the spy/stub was never called with
          matching arguments. This behaves the same as
          <code>spy.neverCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.
        </dd>
        <dt><code>spy.threw();</code></dt>
        <dd>Returns <code>true</code> if spy threw an exception at least once.</dd>
        <dt><code>spy.threw("TypeError");</code></dt>
        <dd>Returns <code>true</code> if spy threw an exception of the provided type at least once.</dd>
        <dt><code>spy.threw(obj);</code></dt>
        <dd>Returns <code>true</code> if spy threw the provided exception object at least once.</dd>
        <dt><code>spy.alwaysThrew();</code></dt>
        <dd>Returns <code>true</code> if spy always threw an exception.</dd>
        <dt><code>spy.alwaysThrew("TypeError");</code></dt>
        <dd>Returns <code>true</code> if spy always threw an exception of the provided type.</dd>
        <dt><code>spy.alwaysThrew(obj);</code></dt>
        <dd>Returns <code>true</code> if spy always threw the provided exception object.</dd>
        <dt><code>spy.returned(obj);</code></dt>
        <dd>
          Returns <code>true</code> if spy returned the provided value at least once.
          Uses deep comparison for objects and arrays.
          Use <code>spy.returned(sinon.match.same(obj))</code> for strict
          comparison (see <a href="#matchers">matchers</a>).
        </dd>
        <dt><code>spy.alwaysReturned(obj);</code></dt>
        <dd>Returns <code>true</code> if spy always returned the provided value.</dd>
        <dt><code>var spyCall = spy.getCall(n);</code></dt>
        <dd>
          <p>
            Returns the <em>nth</em> <a href="#spycall">call</a>. Accessing
            individual calls helps with more detailed behavior verification when
            the spy is called more than once. Example:
          </p>
          <pre class="sh_javascript"><code>sinon.spy(jQuery, "ajax");
jQuery.ajax("/stuffs");
var spyCall = jQuery.ajax.getCall(0);

assertEquals("/stuffs", spyCall.args[0]);</code></pre>
        </dd>
        <dt><code>spy.thisValues</code></dt>
        <dd>
          Array of <code>this</code> objects, <code>spy.thisValues[0]</code> is the <code>this</code>
          object for the first call.
        </dd>
        <dt><code>spy.args</code></dt>
        <dd>
          Array of arguments received, <code>spy.args[0]</code> is an array of
          arguments recevied in the first call.
        </dd>
        <dt><code>spy.exceptions</code></dt>
        <dd>
          Array of exception objects thrown, <code>spy.exceptions[0]</code> is
          the exception thrown by the first call. If the call did not throw an
          error, the value at the call's location in <code>.exceptions</code>
          will be 'undefined'.
        </dd>
        <dt><code>spy.returnValues</code></dt>
        <dd>
          Array of return values, <code>spy.returnValues[0]</code> is the return
          value of the first call. If the call did not explicitly return a
          value, the value at the call's location in <code>.returnValues</code>
          will be 'undefined'.
        </dd>
        <dt><code>spy.reset()</code></dt>
        <dd>
          Resets the state of a spy.
        </dd>
        <dt><code>spy.printf("format string", [arg1, arg2, ...])</code></dt>
        <dd>
          Returns the passed format string with the following replacements performed:
          <ul>
            <li><code>%n</code>: the name of the spy ("spy" by default)</li>
            <li><code>%c</code>: the number of times the spy was called, in words ("once", "twice", etc.)</li>
            <li><code>%C</code>: a list of string representations of the calls to the spy, with each call prefixed by a newline and four spaces</li>
            <li><code>%t</code>: a comma-delimited list of <code>this</code> values the spy was called on</li>
            <li><code>%<var>n</var></code>: the formatted value of the <var>n</var>th argument passed to <code>printf</code></li>
            <li><code>%*</code>: a comma-delimited list of the (non-format string) arguments passed to <code>printf</code></li>
          </ul>
        </dd>
      </dl>
      <h3 id="spycall">Individual spy calls</h3>
      <dl>
        <dt><code>var spyCall = spy.getCall(n)</code></dt>
        <dd>
          <p>
            Returns the <em>nth</em> <a href="#spycall">call</a>. Accessing
            individual calls helps with more detailed behavior verification when
            the spy is called more than once. Example:
          </p>
          <pre class="sh_javascript"><code>sinon.spy(jQuery, "ajax");
jQuery.ajax("/stuffs");
var spyCall = jQuery.ajax.getCall(0);

assertEquals("/stuffs", spyCall.args[0]);</code></pre>
        </dd>
        <dt><code>spyCall.calledOn(obj);</code></dt>
        <dd>Returns <code>true</code> if <code>obj</code> was <code>this</code> for this call.</dd>
        <dt><code>spyCall.calledWith(arg1, arg2, ...);</code></dt>
        <dd>Returns <code>true</code> if call received provided arguments (and possibly others).</dd>
        <dt><code>spyCall.calledWithExactly(arg1, arg2, ...);</code></dt>
        <dd>Returns <code>true</code> if call received provided arguments and no others.</dd>
        <dt><code>spyCall.calledWithMatch(arg1, arg2, ...);</code></dt>
        <dd>Returns <code>true</code> if call received matching arguments (and possibly others). This behaves the same as <code>spyCall.calledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</dd>
        <dt><code>spyCall.notCalledWith(arg1, arg2, ...);</code></dt>
        <dd>Returns <code>true</code> if call did not receive provided arguments.</dd>
        <dt><code>spyCall.notCalledWithMatch(arg1, arg2, ...);</code></dt>
        <dd>Returns <code>true</code> if call did not receive matching arguments. This behaves the same as <code>spyCall.notCalledWith(sinon.match(arg1), sinon.match(arg2), ...)</code>.</dd>
        <dt><code>spyCall.threw();</code></dt>
        <dd>Returns <code>true</code> if call threw an exception.</dd>
        <dt><code>spyCall.threw("TypeError");</code></dt>
        <dd>Returns <code>true</code> if call threw exception of provided type.</dd>
        <dt><code>spyCall.threw(obj);</code></dt>
        <dd>Returns <code>true</code> if call threw provided exception object.</dd>
        <dt><code>spyCall.thisValue</code></dt>
        <dd>The call's <code>this</code> value.</dd>
        <dt><code>spyCall.args</code></dt>
        <dd>Array of received arguments.</dd>
        <dt><code>spyCall.exception</code></dt>
        <dd>Exception thrown, if any.</dd>
        <dt><code>spyCall.returnValue</code></dt>
        <dd>Return value.</dd>
      </dl>
    </div>
    <div class="section" id="stubs">
      <h2>Test stubs <a class="api" href="#stubs-api">API reference</a></h2>
      <h3>What are stubs?</h3>
      <p>
        Test stubs are functions (spies) with pre-programmed behavior. They
        support the full <a href="#spies">test spy API</a> in addition to
        methods which can be used to alter the stub's behavior.
      </p>
      <p>
        As spies, stubs can be either anonymous, or wrap existing
        functions. When wrapping an existing function with a stub, the original
        function is not called.
      </p>
      <h3>When to use stubs?</h3>
      <p>
        Use a stub when you want to:
      </p>
      <ol>
        <li>
          Control a method's behavior from a test to force the code down a
          specific path. Examples include forcing a method to throw an error in
          order to test error handling.
        </li>
        <li>
          When you want to prevent a specific method from being called directly
          (possibly because it triggers undesired behavior, such as a
          XMLHttpRequest or similar).
        </li>
      </ol>
      <p>
        The following example is yet another test from Morgan Roderick's
        PubSubJS which shows how to create an anonymous stub that throws an
        exception when called.
      </p>
      <pre class="sh_javascript"><code>"test should call all subscribers, even if there are exceptions" : function(){
    var message = getUniqueString();
    var error = getUniqueString();
    var stub = sinon.stub().throws();
    var spy1 = sinon.spy();
    var spy2 = sinon.spy();

    PubSub.subscribe(message, stub);
    PubSub.subscribe(message, spy1);
    PubSub.subscribe(message, spy2);

    PubSub.publishSync(message, undefined);

    assert(spy1.called);
    assert(spy2.called);
    assert(stub.calledBefore(spy1));
}</code></pre>
      <p>
        Note how the stub also implements the spy interface. The test verifies
        that all callbacks where called, and also that the exception throwing
        stub was called before one of the other callbacks.
      </p>
      <h3 id="stubs-api">Stub API</h3>
      <dl>
        <dt><code>var stub = sinon.stub();</code></dt>
        <dd>Creates an anonymous stub function.</dd>
        <dt><code>var stub = sinon.stub(object, "method");</code></dt>
        <dd>
          Replaces <code>object.method</code> with a stub function. The original
          function can be restored by calling <code>object.method.restore();</code>
          (or <code>stub.restore();</code>). An exception is thrown if the property
          is not already a function, to help avoid typos when stubbing methods.
        </dd>
        <dt><code>var stub = sinon.stub(object, "method", func);</code></dt>
        <dd>
          Replaces <code>object.method</code> with a <code>func</code>, wrapped
          in a <code>spy</code>. As usual, <code>object.method.restore();</code>
          can be used to restore the original method.
        </dd>
        <dt><code>var stub = sinon.stub(obj);</code></dt>
        <dd>Stubs all the object's methods.</dd>
        <dt>stub.withArgs(arg1[, arg2, ...]);</dt>
        <dd>
          Stubs the method only for the provided arguments. This is useful to be
          more expressive in your assertions, where you can access the spy with
          the same call. It is also useful to create a stub that can act
          differently in response to different arguments:
          <pre class="sh_javascript"><code>"test should stub method differently based on arguments": function () {
    var callback = sinon.stub();
    callback.withArgs(42).returns(1);
    callback.withArgs(1).throws("TypeError");

    callback(); // No return value, no exception
    callback(42); // Returns 1
    callback(1); // Throws TypeError
}</code></pre>
        </dd>
        <dt><code>stub.returns(obj);</code></dt>
        <dd>Makes the stub return the provided value.</dd>
        <dt><code>stub.returnsArg(index);</code></dt>
        <dd>
          Causes the stub to return the argument at the provided index.
          <code>stub.returnsArg(0);</code> causes the stub to return the first argument.
        </dd>
        <dt><code>stub.throws();</code></dt>
        <dd>Causes the stub to throw an exception (<code>Error</code>).</dd>
        <dt><code>stub.throws("TypeError");</code></dt>
        <dd>Causes the stub to throw an exception of the provided type.</dd>
        <dt><code>stub.throws(obj);</code></dt>
        <dd>Causes the stub to throw the provided exception object.</dd>
        <dt><code>stub.callsArg(index);</code></dt>
        <dd>
          Causes the stub to call the argument at the provided index as a callback
          function. <code>stub.callsArg(0);</code> causes the stub to call the
          first argument as a callback.
        </dd>
        <dt><code>stub.callsArgOn(index, context);</code></dt>
        <dd>
          Like above but with an additional parameter to pass the <code>this</code> context.
        </dd>
        <dt><code>stub.callsArgWith(index, arg1, arg2, ...);</code></dt>
        <dd>Like <code>callsArg</code>, but with arguments to pass to the callback.</dd>
        <dt><code>stub.callsArgOnWith(index, context, arg1, arg2, ...);</code></dt>
        <dd>
          Like above but with an additional parameter to pass the <code>this</code> context.
        </dd>
        <dt>stub.yields([arg1, arg2, ...])</dt>
        <dd>
          Almost like <code>callsArg</code>. Causes the stub to call the first
          callback it receives with the provided arguments (if any). If a method
          accepts more than one callback, you need to use <code>callsArg</code>
          to have the stub invoke other callbacks than the first one.
        </dd>
        <dt>stub.yieldsOn(context, [arg1, arg2, ...])</dt>
        <dd>
          Like above but with an additional parameter to pass the <code>this</code> context.
        </dd>
        <dt><code>stub.yieldsTo(property, [arg1, arg2, ...])</code></dt>
        <dd>
          Causes the spy to invoke a callback passed as a property of an object
          to the spy. Like <code>yields</code>, <code>yieldsTo</code> grabs the
          first matching argument, finds the callback and calls it with the
          (optional) arguments:
        <dt><code>stub.yieldsToOn(property, context, [arg1, arg2, ...])</code></dt>
        </dd>
        <dd>
          Like above but with an additional parameter to pass the <code>this</code> context.
        </dd>
          <pre class="sh_javascript"><code>"test should fake successful ajax request": function () {
    sinon.stub(jQuery, "ajax").yieldsTo("success", [1, 2, 3]);

    jQuery.ajax({
        success: function (data) {
            assertEquals([1, 2, 3], data);
        }
    });
}</code></pre>
        </dd>
        <dt><code>spy.yield([arg1, arg2, ...])</code></dt>
        <dd>
          Invoke callbacks passed to the <code>spy</code> with the given
          arguments. If the spy was never called with a function argument,
          <code>yield</code> throws an error. Also aliased as
          <code>invokeCallback</code>.
        </dd>
        <dt><code>spy.yieldTo(callback, [arg1, arg2, ...])</code></dt>
        <dd>
          Invokes callbacks passed as a property of an object to the
          spy. Like <code>yield</code>, <code>yieldTo</code> grabs the first
          matching argument, finds the callback and calls it with the (optional)
          arguments:
          <pre class="sh_javascript"><code>"calling callbacks": function () {
    var callback = sinon.stub();
    callback({
        "success": function () {
            console.log("Success!");
        },
        "failure": function () {
            console.log("Oh noes!");
        }
    });

    callback.yieldTo("failure"); // Logs "Oh noes!"
}</code></pre>
        </dd>
        <dt><code>spy.callArg(argNum)</code></dt>
        <dd>
          Like <code>yield</code>, but with an explicit argument number
          specifying which callback to call. Useful if a function is called with
          more than one callback, and simply calling the first callback is not
          desired.
          <pre class="sh_javascript"><code>"calling the last callback": function () {
    var callback = sinon.stub();
    callback(function () {
        console.log("Success!");
    },
    function () {
        console.log("Oh noes!");
    });

    callback.callArg(1); // Logs "Oh noes!"
}</code></pre>
        </dd>
        <dt><code>spy.callArgWith(argNum, [arg1, arg2, ...])</code></dt>
        <dd>
          Like <code>callArg</code>, but with arguments.
        </dd>
      </dl>
    </div>
    <div class="section" id="mocks">
      <h2>Mocks <a class="api" href="#mocks-api">API reference</a></h2>
      <h3>What are mocks?</h3>
      <p>
        Mocks (and mock expectations) are fake methods (like spies) with
        pre-programmed behavior (like stubs) as well as <em>pre-programmed
        expectations</em>. A mock will fail your test if it is not used as
        expected.
      </p>
      <h3>When to use mocks?</h3>
      <p>
        Mocks should only be used for the <em>method under test</em>. In every
        unit test, there should be one unit under test. If you want to control
        how your unit is being used and like stating expectations upfront (as
        opposed to asserting after the fact), use a mock.
      </p>
      <h3>When to <strong>not</strong> use mocks?</h3>
      <p>
        Mocks come with built-in expectations that may fail your test. Thus,
        they enforce implementation details. The rule of thumb is: if you
        wouldn't add an assertion for some call specific, don't mock it. Use a
        stub instead. In general you should never have more
        than <strong>one</strong> mock (possibly with several expectations) in a
        single test.
      </p>
      <p>
        <a href="#expectations">Expectations</a> implement both
        the <a href="#spies">spies</a> and <a href="#stubs">stubs</a> APIs.
      </p>
      <p>
        To see how mocks look like in Sinon.JS, here's one of the PubSubJS tests
        again, this time using a method as callback and using mocks to verify
        its behavior:
      </p>
      <pre class="sh_javascript"><code>"test should call all subscribers when exceptions": function () {
    var myAPI = { method: function () {} };

    var spy = sinon.spy();
    var mock = sinon.mock(myAPI);
    mock.expects("method").once().throws();

    PubSub.subscribe("message", myAPI.method);
    PubSub.subscribe("message", spy);
    PubSub.publishSync("message", undefined);

    mock.verify();
    assert(spy.calledOnce);
}</code></pre>
      <h3 id="mocks-api">Mock API</h3>
      <dl>
        <dt><code>var mock = sinon.mock(obj);</code></dt>
        <dd>
          Creates a mock for the provided object. Does not change the object, but returns
          a mock object to set expectations on the object's methods.
        </dd>
        <dt><code>var expectation = mock.expects("method");</code></dt>
        <dd>
          Overrides <code>obj.method</code> with a mock function and returns it.
          See <a href="#expectations">expectations</a> below.
        </dd>
        <dt><code>mock.restore();</code></dt>
        <dd>Restores all mocked methods.</dd>
        <dt><code>mock.verify();</code></dt>
        <dd>
          Verifies all expectations on the mock. If any expectation is not
          satiesfied, an exception is thrown. Also restores the mocked methods.
        </dd>
      </dl>
      <h3 id="expectations">Expectations</h3>
      <p>
        All the expectation methods returns the expectation, meaning you can chain them.
        Typical usage:
      </p>
      <pre class="sh_javascript"><code>sinon.mock(jQuery).expects("ajax").atLeast(2).atMost(5);
jQuery.ajax.verify();</code></pre>
      <dl>
        <dt><code>var expectation = sinon.expectation.create([methodName]);</code></dt>
        <dd>
          Creates an expectation without a mock object, basically an anonymous
          mock function. Method name is optional and is used in exception
          messages to make them more readable.
        </dd>
        <dt><code>var expectation = sinon.mock();</code></dt>
        <dd>The same as the above.</dd>
        <dt><code>expectation.atLeast(number);</code></dt>
        <dd>Specify the minimum amount of calls expected.</dd>
        <dt><code>expectation.atMost(number);</code></dt>
        <dd>Specify the maximum amount of calls expected.</dd>
        <dt><code>expectation.never();</code></dt>
        <dd>Expect the method to never be called.</dd>
        <dt><code>expectation.once();</code></dt>
        <dd>Expect the method to be called exactly once.</dd>
        <dt><code>expectation.twice();</code></dt>
        <dd>Expect the method to be called exactly twice.</dd>
        <dt><code>expectation.thrice();</code></dt>
        <dd>Expect the method to be called exactly thrice.</dd>
        <dt><code>expectation.exactly(number);</code></dt>
        <dd>Expect the method to be called exactly <code>number</code> times.</dd>
        <dt><code>expectation.withArgs(arg1, arg2, ...);</code></dt>
        <dd>Expect the method to be called with the provided arguments and possibly others.</dd>
        <dt><code>expectation.withExactArgs(arg1, arg2, ...);</code></dt>
        <dd>Expect the method to be called with the provided arguments and no others.</dd>
        <dt><code>expectation.on(obj);</code></dt>
        <dd>Expect the method to be called with <code>obj</code> as <code>this</code>.</dd>
        <dt><code>expecation.verify();</code></dt>
        <dd>Verifies the expectation and throws an exception if it's not met.</dd>
      </dl>
   </div>
    <div class="section" id="clock">
      <h2>Fake timers <a class="api" href="#clock-api">API reference</a></h2>
      <p>
        Fake timers is a synchronous implementation of <code>setTimeout</code>
        and friends that Sinon.JS can overwrite the global functions with to
        allow you to more easily test code using them. Fake timers provide
        a <code>clock</code> object to pass time, which can also be used to
        control <code>Date</code> objects created through either <code>new
        Date();</code> or <code>Date.now();</code> (if supported by the
        browser).
      </p>
      <p>
        When faking timers with IE you also need
        <a href="../releases/sinon-ie-1.3.4.js">sinon-ie-1.3.4</a>, which should be
        loaded after sinon-1.3.4.js.
      </p>
      <p>
        The fake timers can be used completely stand-alone by downloading
        <a href="../releases/sinon-timers-1.3.4.js">sinon-timers-1.3.4</a>. When
        using the fake timers in IE you also need
        <a href="../releases/sinon-timers-ie-1.3.4.js">sinon-timers-ie-1.3.4</a>.
        Load it after the first file.
      </p>
      <pre class="sh_javascript timers"><code>{
    setUp: function () {
        this.clock = sinon.useFakeTimers();
    },

    tearDown: function () {
        this.clock.restore();
    },

    "test should animate element over 500ms" : function(){
        var el = jQuery("&lt;div>&lt;/div>");
        el.appendTo(document.body);

        el.animate({ height: "200px", width: "200px" });
        this.clock.tick(510);

        assertEquals("200px", el.css("height"));
        assertEquals("200px", el.css("width"));
    }
}</code></pre>
      <h3 id="clock-api">Fake timers API</h3>
      <dl>
        <dt><code>var clock = sinon.useFakeTimers();</code></dt>
        <dd>
          <p>
            Causes Sinon to replace the global <code>setTimeout</code>,
            <code>clearTimeout</code>, <code>setInterval</code>,
            <code>clearInterval</code> and <code>Date</code> with a custom
            implementation which is bound to the returned <code>clock</code>
            object.
          </p>
        </dd>
        <dt><code>var clock = sinon.useFakeTimers(now);</code></dt>
        <dd>
          As above, but rather than starting the clock at the current timestamp,
          start at the provided timestamp.
        </dd>
        <dt><code>var clock = sinon.useFakeTimers([now, ]prop1, prop2, ...);</code></dt>
        <dd>
          Sets the clock start timestamp and names functions to fake. Possible
          functions are setTimeout, clearTimeout, setInterval, clearInterval,
          and Date. Can also be called without the timestamp.
        </dd>
        <dt><code>clock.tick(ms);</code></dt>
        <dd>
          Tick the clock ahead <code>ms</code> milliseconds. Causes all timers
          scheduled within the affected time range to be called.
        </dd>
        <dt><code>clock.restore();</code></dt>
        <dd>Restore the faked methods. Call in e.g. <code>tearDown</code>.</dd>
      </dl>
    </div>
    <div class="section" id="server">
      <h2>Fake <code>XMLHttpRequest</code> <a class="api" href="#useFakeXMLHttpRequest">API reference</a></h2>
      <ul class="nav">
        <li><a href="#useFakeXMLHttpRequest">sinon.useFakeXMLHttpRequest</a></li>
        <li><a href="#FakeXMLHttpRequest">FakeXMLHttpRequest</a></li>
        <li><a href="#responses">Simulating responses</a></li>
        <li><a href="#fakeServer">Fake server</a></li>
      </ul>
      <p>
        Provides a fake implementation of <code>XMLHttpRequest</code> and
        provides several interfaces for manipulating objects created by it. Also
        fakes the native <code>XMLHttpRequest</code>
        and <code>ActiveXObject</code> (if available, and only
        for <code>XMLHTTP</code> progids).  Helps with testing requests made
        with XHR.
      </p>
      <p>
        When faking XHR with IE you also need
        <a href="../releases/sinon-ie-1.3.4.js">sinon-ie-1.3.4</a>, which should be
        loaded after sinon-1.3.4.js.
      </p>
      <p>
        The fake server and XHR can be used completely stand-alone by
        downloading <a href="../releases/sinon-server-1.3.4.js">sinon-server-1.3.4</a>.
        When using the fake server in IE you also need
        <a href="../releases/sinon-ie-1.3.4.js">sinon-ie-1.3.4</a>. Load it after
        the first file.
      </p>
      <pre class="sh_javascript timers"><code>{
    setUp: function () {
        this.xhr = sinon.useFakeXMLHttpRequest();
        var requests = this.requests = [];

        this.xhr.onCreate = function (xhr) {
            requests.push(xhr);
        };
    },

    tearDown: function () {
        this.xhr.restore();
    },

    "test should fetch comments from server" : function () {
        var callback = sinon.spy();
        myLib.getCommentsFor("/some/article", callback);
        assertEquals(1, this.requests.length);

        this.requests[0].respond(200, { "Content-Type": "application/json" },
                                 '[{ "id": 12, "comment": "Hey there" }]');
        assert(callback.calledWith([{ id: 12, comment: "Hey there" }]));
    }
}</code></pre>
      <h3 id="useFakeXMLHttpRequest"><code>sinon.useFakeXMLHttpRequest</code></h3>
      <dl>
        <dt><code>var xhr = sinon.useFakeXMLHttpRequest();</code></dt>
        <dd>
          Causes Sinon to replace the native <code>XMLHttpRequest</code> object
          in browsers that support it with a custom implementation which does
          not send actual requests. In browsers that support
          <code>ActiveXObject</code>, this constructor is replaced, and fake
          objects are returned for <code>XMLHTTP</code> progIds. Other progIds,
          such as <code>XMLDOM</code> are left untouched.
        </dd>
        <dt><code>xhr.onCreate = function (xhr) {};</code></dt>
        <dd>
          By assigning a function to the <code>onCreate</code> property of the
          returned object from <code>useFakeXMLHttpRequest()</code> you can
          subscribe to newly created <code>FakeXMLHttpRequest</code>
          objects. See below for the fake xhr object API. Using this observer
          means you can still reach objects created by
          e.g. <code>jQuery.ajax</code> (or other abstractions/frameworks).
        </dd>
        <dt><code>xhr.restore();</code></dt>
        <dd>Restore original function(s).</dd>
      </dl>
      <h3 id="FakeXMLHttpRequest"><code>FakeXMLHttpRequest</code> interface</h3>
      <dl>
        <dt>String <code>request.url</code></dt>
        <dd>
          The URL set on the request object.
        </dd>
        <dt>String <code>request.method</code></dt>
        <dd>
          The request method as a string.
        </dd>
        <dt>Object <code>request.requestHeaders</code></dt>
        <dd>
          <p>
            An object of all request headers, i.e.:
          </p>
          <pre class="sh_javascript"><code>{
    "Accept": "text/html, */*",
    "Connection": "keep-alive"
}</code></pre>
        </dd>
        <dt>String <code>request.requestBody</code></dt>
        <dd>The request body</dd>
        <dt>int <code>request.status</code></dt>
        <dd>
          The request's status code. Undefined if the request has not been
          handled (see <a href="#respond"><code>respond</code></a> below).
        </dd>
        <dt>String <code>request.statusText</code></dt>
        <dd>
          Only populated if the <a href="#respond"><code>respond</code></a>
          method is called (see below).
        </dd>
        <dt>boolean <code>request.async</code></dt>
        <dd>
          Whether or not the request is asynchronous.
        </dd>
        <dt>String <code>request.username</code></dt>
        <dd>
          Username, if any.
        </dd>
        <dt>String <code>request.password</code></dt>
        <dd>
          Password, if any.
        </dd>
        <dt>Document <code>request.responseXML</code></dt>
        <dd>
          When using <a href="#respond"><code>respond</code></a>, this property is
          populated with a parsed document if response headers indicate as much
          (see <a href="http://www.w3.org/TR/XMLHttpRequest/">the spec</a>).
        </dd>
        <dt>String <code>request.getResponseHeader(header);</code></dt>
        <dd>
          The value of the given response header, if the request has been
          responded to (see <a href="#respond"><code>respond</code></a>).
        </dd>
        <dt>Object <code>request.getAllResponseHeaders();</code></dt>
        <dd>
          All response headers as an object.
        </dd>
      </dl>
      <h3 id="filtered-requests">Filtered requests</h3>
      <p>
        When using Sinon.JS for mockups or partial integration/functional
        testing, you might want to fake some requests, while allowing others to
        go throught to the backend server. With
        filtered <code>FakeXMLHttpRequest</code>s (new in Sinon 1.3.0), you can.
      </p>
      <dl>
        <dt><code>FakeXMLHttpRequest.useFilters</code> (default <code>false</code>)</dt>
        <dd>
          When set to <code>true</code>, Sinon will check added filters if
          certain requests should be "unfaked".
        </dd>
        <dt><code>FakeXMLHttpRequest.addFilter(fn)</code></dt>
        <dd>
          Add a filter that will decide whether or not to fake a request. The
          filter will be called when <code>xhr.open</code> is called, with the
          exact same arguments (<code>method</code>, <code>url</code>,
          <code>async</code>, <code>username</code>, <code>password</code>). If
          the filter returns truthy, the request will not be faked.
        </dd>
      </dl>
      <h3 id="responses">Simulating server responses</h3>
      <dl>
        <dt><code>request.setResponseHeaders(object);</code></dt>
        <dd>
          Sets response headers (e.g. <code>{ "Content-Type": "text/html", /*
          ... */ }</code>, updates the <code>readyState</code> property and
          fires <code>onreadystatechange</code>.
        </dd>
        <dt><code>request.setResponseBody(body);</code></dt>
        <dd>
          Sets the respond body, updates the <code>readyState</code> property and
          fires <code>onreadystatechange</code>. Additionally,
          populates <code>responseXML</code> with a parsed document
          if <a href="http://www.w3.org/TR/XMLHttpRequest/">response headers indicate as much</a>.
        </dd>
        <dt id="respond"><code>request.respond(status, headers, body);</code></dt>
        <dd>
          Calls the above two methods and sets the <code>status</code> and
          <code>statusText</code> properties. Status should be a number, the
          status text is looked up from <code>sinon.FakeXMLHttpRequest.statusCodes</code>.
        </dd>
        <dt id="auto-respond"><code>request.autoRespond(ms);</code></dt>
        <dd>
          Causes the server to automatically respond to incoming requests after
          a timeout. The default timeout is 10ms but you can control it through
          the <code>ms</code> argument. Note that this feature is intended to
          help during mockup development, and is not suitable for use in tests.
        </dd>
      </dl>
      <h3 id="fakeServer">Fake server</h3>
      <p>
        High-level API to manipulate <code>FakeXMLHttpRequest</code> instances.
      </p>
      <pre id="server_example" class="sh_javascript timers"><code>{
    setUp: function () {
        this.server = sinon.fakeServer.create();
    },

    tearDown: function () {
        this.server.restore();
    },

    "test should fetch comments from server" : function () {
        this.server.respondWith("GET", "/some/article/comments.json",
                                [200, { "Content-Type": "application/json" },
                                 '[{ "id": 12, "comment": "Hey there" }]']);

        var callback = sinon.spy();
        myLib.getCommentsFor("/some/article", callback);
        this.server.respond();

        sinon.assert.calledWith(callback, [{ id: 12, comment: "Hey there" }]));
    }
}</code></pre>
      <dl>
        <dt><code>var server = sinon.fakeServer.create();</code></dt>
        <dd>
          Creates a new server. This function also calls <code>sinon.useFakeXMLHttpRequest()</code>.
        </dd>
        <dt><code>var server = sinon.fakeServerWithClock.create();</code></dt>
        <dd>
          Creates a server that also manages fake timers. This is useful when
          testing XHR objects created with e.g. jQuery 1.3.x, which uses a timer
          to poll the object for completion, rather than the usual <code>onreadystatechange</code>.
        </dd>
        <dt><code>server.respondWith(response);</code></dt>
        <dd>
          <p>
            <code>response</code> is either a string - the response body, an array
            with status, headers and response body, e.g.
            <code>[200, { "Content-Type": "text/html", "Content-Length": 2 },
            "OK"]</code> or a function. Default status is 200 and default headers
            are none. Causes the server to respond to any request not matched by
            another response with the provided data. The default catch-all
            response is <code>[404, {} ""]</code>.
          </p>
          <p>
            When the response is a function, it will be passed the request
            object. You must manually call <a href="#respond">respond</a> on it
            to complete the request.
          </p>
        </dd>
        <dt><code>server.respondWith(url, response);</code></dt>
        <dd>
          Responds to all requests to given URL, e.g. <code>/posts/1</code>.
        </dd>
        <dt><code>server.respondWith(method, url, response);</code></dt>
        <dd>
          Responds to all <code>method</code> requests to the given URL with the
          given response. <code>method</code> is an HTTP verb.
        </dd>
        <dt><code>server.respondWith(urlRegExp, response);</code></dt>
        <dd>
          URL may be a regular expression, e.g. <code>/\/post/\d+</code>
          If the response is a function, it will be passed any capture groups
          from the regular expression along with the XMLHttpRequest object:
          <pre class="sh_javascript"><code>server.respondWith(/\/todo-items\/(\d+)/, function (xhr, id) {
    xhr.respond(200, { "Content-Type": "application/json" }, '[{ "id": ' + id + ' }]');
});</code></pre>
        </dd>
        <dt><code>server.respondWith(method, urlRegExp, response);</code></dt>
        <dd>
          Responds to all <code>method</code> requests to URLs matching the
          regular expression.
        </dd>
        <dt><code>server.respond();</code></dt>
        <dd>
          Causes all queued asynchronous requests to receive a response. If none
          of the responses added through <code>respondWith</code> match, the
          default response is <code>[404, {}, ""]</code>. Synchronous requests
          are responded to immediately, so make sure to call
          <code>respondWith</code> upfront. If called with arguments,
          <code>respondWith</code> will be called with those arguments before
          responding to requests.
        </dd>
        <dt><code>server.autoRespond = true;</code></dt>
        <dd>
          If set, will call to <code>srv.respondWith</code> automatically after every request. 
        </dd>
        <dt><code>server.autoRespondAfter = ms;</code></dt>
        <dd>
          Causes the server to automatically respond to incoming requests after
          a timeout. 
        </dd>
        <dt>Boolean <code>server.fakeHTTPMethods</code></dt>
        <dd>
          If set to <code>true</code>, server will find <code>_method</code>
          parameter in POST body and recognize that as the actual
          method. Supports a pattern common to Ruby on Rails applications. For
          custom HTTP method faking,
          override <code>server.getHTTPMethod(request)</code>.
        </dd>
        <dt><code>server.getHTTPMethod(request)</code></dt>
        <dd>
          Used internally to determine the HTTP method used with the provided
          request. By default this method simply
          returns <code>request.method</code>. When <code>server.fakeHTTPMethods</code>
          is true, the method will return the value of the <code>_method</code>
          parameter if the method is "POST". This method can be overrided to
          provide custom behavior.
        </dd>
        <dt><code>server.restore();</code></dt>
        <dd>
          Restores the native XHR constructor.
        </dd>
      </dl>
    </div>
    <div class="section" id="assertions">
      <h2>Assertions <a class="api" href="#assertions-api">API reference</a></h2>
      <p>
        Sinon.JS ships with a set of assertions that mirror most behavior
        verification methods and properties on spies and stubs. The advantage of
        using the assertions is that failed expectations on stubs and spies can
        be expressed directly as assertion failures with detailed and helpful
        error messages.
      </p>
      <p>
        To make sure assertions integrate nicely with your test framework, you
        should customize either <code>sinon.assert.fail</code> or
        <code>sinon.assert.failException</code> and look into
        <a href="#assert-expose"><code>sinon.assert.expose</code></a> and
        <a href="#assert-pass"><code>sinon.assert.pass</code></a>.
      </p>
      <p>
        The assertions can be used with either spies or stubs.
      </p>
      <pre class="sh_javascript mocks"><code>"test should call subscribers with message as first argument" : function () {
    var message = getUniqueString();
    var spy = sinon.spy();

    PubSub.subscribe(message, spy);
    PubSub.publishSync(message, "some payload");

    sinon.assert.calledOnce(spy);
    sinon.assert.calledWith(spy, message);
}</code></pre>
      <h3 id="assertions-api">Assertions API</h3>
      <dl>
        <dt><code>sinon.assert.fail(message)</code></dt>
        <dd>
          Every assertion fails by calling this method. By default it throws an
          error of type <code>sinon.assert.failException</code>. If your testing
          framework looks for assertion errors by checking for a specific
          exception, you can simply override the kind of exception thrown. If
          that does not fit with your testing framework of choice, override
          the <code>fail</code> method to do the right thing.
        </dd>
        <dt>String <code>sinon.assert.failException</code></dt>
        <dd>
          Defaults to "AssertError".
        </dd>
        <dt id="assert-pass"><code>sinon.assert.pass(assertion)</code></dt>
        <dd>
          Called every time an assertion passes. Default implementation does
          nothing.
        </dd>
        <dt><code>sinon.assert.notCalled(spy)</code></dt>
        <dd>
          Passes if spy was never called.
        </dd>
        <dt><code>sinon.assert.called(spy)</code></dt>
        <dd>
          Passes if spy was called at least once.
        </dd>
        <dt><code>sinon.assert.calledOnce(spy)</code></dt>
        <dd>
          Passes if spy was called once and only once.
        </dd>
        <dt><code>sinon.assert.calledTwice()</code></dt>
        <dd>
          Passes if spy was called exactly twice.
        </dd>
        <dt><code>sinon.assert.calledThrice()</code></dt>
        <dd>
          Passes if spy was called exactly three times.
        </dd>
        <dt><code>sinon.assert.callCount(spy, num)</code></dt>
        <dd>
          Passes if the spy was called exactly <code>num</code> times.
        </dd>
        <dt><code>sinon.assert.callOrder(spy1, spy2, ...)</code></dt>
        <dd>
          Passes if the provided spies where called in the specified order.
        </dd>
        <dt><code>sinon.assert.calledOn(spy, obj)</code></dt>
        <dd>
          Passes if the spy was ever called with <code>obj</code> as
          its <code>this</code> value.
        </dd>
        <dt><code>sinon.assert.alwaysCalledOn(spy, obj)</code></dt>
        <dd>
          Passes if the spy was always called with <code>obj</code> as
          its <code>this</code> value.
        </dd>
        <dt><code>sinon.assert.calledWith(spy, arg1, arg2, ...)</code></dt>
        <dd>
          Passes if the spy was called with the provided arguments.
        </dd>
        <dt><code>sinon.assert.alwaysCalledWith(spy, arg1, arg2, ...)</code></dt>
        <dd>
          Passes if the spy was always called with the provided arguments.
        </dd>
        <dt><code>sinon.assert.neverCalledWith(spy, arg1, arg2, ...)</code></dt>
        <dd>
          Passes if the spy was never called with the provided arguments.
        </dd>
        <dt><code>sinon.assert.calledWithExactly(spy, arg1, arg2, ...)</code></dt>
        <dd>
          Passes if the spy was called with the provided arguments and no others.
        </dd>
        <dt><code>sinon.assert.alwaysCalledWithExactly(spy, arg1, arg2, ...)</code></dt>
        <dd>
          Passes if the spy was always called with the provided arguments and no
          others.
        </dd>
        <dt><code>sinon.assert.calledWithMatch(spy, arg1, arg2, ...)</code></dt>
        <dd>
          Passes if the spy was called with matching arguments. This behaves
          the same as <code>sinon.assert.calledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.
        </dd>
        <dt><code>sinon.assert.alwaysCalledWithMatch(spy, arg1, arg2, ...)</code></dt>
        <dd>
          Passes if the spy was always called with matching arguments. This behaves
          the same as <code>sinon.assert.alwaysCalledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.
        </dd>
        <dt><code>sinon.assert.neverCalledWithMatch(spy, arg1, arg2, ...)</code></dt>
        <dd>
          Passes if the spy was never called with matching arguments. This behaves
          the same as <code>sinon.assert.neverCalledWith(spy, sinon.match(arg1), sinon.match(arg2), ...)</code>.
        </dd>
        <dt><code>sinon.assert.threw(spy, exception)</code></dt>
        <dd>
          Passes if the spy threw the given exception. The exception can be a
          string denoting its type, or an actual object. If only one argument is
          provided, the assertion passes if the spy ever threw any exception.
        </dd>
        <dt><code>sinon.assert.alwaysThrew(spy, exception)</code></dt>
        <dd>
          Like above, only required for all calls to the spy.
        </dd>
        <dt id="assert-expose"><code>sinon.assert.expose(object, options)</code></dt>
        <dd>
          <p>
            Exposes assertions into another object, to better integrate with the
            test framework. For instance, JsTestDriver uses global assertions, and
            to make Sinon.JS assertions appear alongside them, you can do:
          </p>
          <pre class="sh_javascript"><code>sinon.assert.expose(this);</code></pre>
          <p>
            This will give you <code>assertCalled(spy)</code>,
            <code>assertCallOrder(spy1, spy2, ...)</code> and so on.
          </p>
          <p>
            The method accepts an optional options object with two
            options. <strong>prefix</strong> is a prefix to give assertions. By
            default it is "assert", so <code>sinon.assert.called</code> becomes
            <code>target.assertCalled</code>. By passing a blank string, the
            exposed method will be <code>target.called</code>. The second
            option, <strong>includeFail</strong> is true by default, and copies
            over the <code>fail</code> and <code>failException</code>
            properties.
          </p>
        </dd>
      </dl>
    </div>
    <div class="section" id="matchers">
      <h2>Matchers <a class="api" href="#sinon-match-api">API reference</a></h2>
      <ul class="nav">
        <li><a href="#sinon-match-api">Matcher API</a></li>
        <li><a href="#sinon-match-andor">Combining matchers</a></li>
        <li><a href="#sinon-match-custom">Custom matchers</a></li>
      </ul>
      <p>
        Matchers can be passed as arguments to <code>spy.calledWith</code>,
        <code>spy.returned</code> and the corresponding
        <code>sinon.assert</code> functions as well as
        <code>spy.withArgs</code>. Matchers allow to be either
        more fuzzy or more specific about the expected value.
      </p>
      <pre class="sh_javascript"><code>"test should assert fuzzy": function () {
    var book = {
        pages: 42,
        author: "cjno"
    };
    var spy = sinon.spy();

    spy(book);

    sinon.assert.calledWith(spy, sinon.match({ author: "cjno" }));
    sinon.assert.calledWith(spy, sinon.match.has("pages", 42));
}</code></pre>
      <pre class="sh_javascript"><code>"test should stub method differently based on argument types": function () {
    var callback = sinon.stub();
    callback.withArgs(sinon.match.string).returns(true);
    callback.withArgs(sinon.match.number).throws("TypeError");

    callback("abc"); // Returns true
    callback(123); // Throws TypeError
}</code></pre>
      <h3 id="sinon-match-api">Matchers API</h3>
      <dl>
        <dt><code>sinon.match(number)</code></dt>
        <dd>Requires the value to be == to the given number.</dd>
        <dt><code>sinon.match(string)</code></dt>
        <dd>Requires the value to be a string and have the expectation as a substring.</dd>
        <dt><code>sinon.match(regexp)</code></dt>
        <dd>Requires the value to be a string and match the given regular expression.</dd>
        <dt><code>sinon.match(object)</code></dt>
        <dd>Requires the value to be not null or undefined and have at least the same properties as <code>expectation</code>. This supports nested matchers.</dd>
        <dt><code>sinon.match(function)</code></dt>
        <dd>See <a href="#sinon-match-custom">custom matchers</a>.</dd>
        <dt><code>sinon.match.any</code></dt>
        <dd>Matches anything.</dd>
        <dt><code>sinon.match.defined</code></dt>
        <dd>Requires the value to be defined.</dd>
        <dt><code>sinon.match.truthy</code></dt>
        <dd>Requires the value to be truthy.</dd>
        <dt><code>sinon.match.falsy</code></dt>
        <dd>Requires the value to be falsy.</dd>
        <dt><code>sinon.match.bool</code></dt>
        <dd>Requires the value to be a boolean.</dd>
        <dt><code>sinon.match.number</code></dt>
        <dd>Requires the value to be a number.</dd>
        <dt><code>sinon.match.string</code></dt>
        <dd>Requires the value to be a string.</dd>
        <dt><code>sinon.match.object</code></dt>
        <dd>Requires the value to be an object.</dd>
        <dt><code>sinon.match.func</code></dt>
        <dd>Requires the value to be a function.</dd>
        <dt><code>sinon.match.array</code></dt>
        <dd>Requires the value to be an array.</dd>
        <dt><code>sinon.match.regexp</code></dt>
        <dd>Requires the value to be a regular expression.</dd>
        <dt><code>sinon.match.date</code></dt>
        <dd>Requires the value to be a date object.</dd>
        <dt><code>sinon.match.same(ref)</code></dt>
        <dd>Requires the value to strictly equal <code>ref</code>.</dd>
        <dt><code>sinon.match.typeOf(type)</code></dt>
        <dd>Requires the value to be of the given type, where <code>type</code> can be one of
          <code>&quot;undefined&quot;</code>,
          <code>&quot;null&quot;</code>,
          <code>&quot;boolean&quot;</code>,
          <code>&quot;number&quot;</code>,
          <code>&quot;string&quot;</code>,
          <code>&quot;object&quot;</code>,
          <code>&quot;function&quot;</code>,
          <code>&quot;array&quot;</code>,
          <code>&quot;regexp&quot;</code> or
          <code>&quot;date&quot;</code>.
        </dd>
        <dt><code>sinon.match.instanceOf(type)</code></dt>
        <dd>Requires the value to be an instance of the given type.</dd>
        <dt><code>sinon.match.has(property[, expectation])</code></dt>
        <dd>Requires the value to define the given property. The property might be inherited via the prototype chain. If the optional expectation is given, the value of the property is deeply compared with the expectation. The expectation can be another matcher.</dd>
        <dt><code>sinon.match.hasOwn(property[, expectation])</code></dt>
        <dd>Same as <code>sinon.match.has</code> but the property must be defined by the value itself. Inherited properties are ignored.</dd>
      </dl>
      <h3 id="sinon-match-andor">Combining matchers</h3>
      <p>
        All matchers implement <code>and</code> and <code>or</code>. This
        allows to logically combine mutliple matchers. The result is a new
        matchers that requires both (and) or one of the matchers (or) to
        return true.
      </p>
      <pre class="sh_javascript"><code>var stringOrNumber = sinon.match.string.or(sinon.match.number);

var bookWithPages = sinon.match.instanceOf(Book).and(sinon.match.has("pages"));</code></pre>
      <h3 id="sinon-match-custom">Custom matchers</h3>
      <p>
        Custom matchers are created with the <code>sinon.match</code> factory
        which takes a test function and an optional message. The test function takes a
        value as the only argument, returns <code>true</code> if the
        value matches the expectation and <code>false</code> otherwise.
        The message string is used to generate the error message in case the
        value does not match the expectation.
      </p>
      <pre class="sh_javascript"><code>var trueIsh = sinon.match(function (value) {
    return !!value;
}, "trueIsh");</code></pre>
    </div>
    <div class="section" id="sandbox">
      <h2>Sandboxes <a class="api" href="#sinon-sandbox">API reference</a></h2>
      <ul class="nav">
        <li><a href="#sinon-sandbox">sinon.sandbox</a></li>
        <li><a href="#sinon-test">sinon.test</a></li>
        <li><a href="#sinon-testCase">sinon.testCase</a></li>
      </ul>
      <p>
        Sandboxes simplify working with fakes that need to be restored and/or
        verified. If you're using fake timers, fake XHR, or you are
        stubbing/spying on globally accessible properties you should use a
        sandbox to ease cleanup. By default the spy, stub and mock properties of
        the sandbox is bound to whatever object the function is run on, so if you
        don't want to manually restore(), you have to use this.spy() instead of
        sinon.spy() (and stub, mock).
      </p>
      <pre class="sh_javascript"><code>"test using sinon.test sandbox": sinon.test(function () {
    var myAPI = { method: function () {} };
    this.mock(myAPI).expects("method").once();

    PubSub.subscribe("message", myAPI.method);
    PubSub.publishSync("message", undefined);
})</code></pre>
      <dl id="sinon-sandbox">
        <dt><code>var sandbox = sinon.sandbox.create();</code></dt>
        <dd>Creates a sandbox object.</dd>
        <dt><code>var sandbox = sinon.sandbox.create(config);</code></dt>
        <dd>
          <p>
            The <code>sinon.sandbox.create(config)</code> method is mostly an
            integration feature, and as an end-user of Sinon.JS you will
            probably not need it.
          </p>
          <p>
            Creates a pre-configured sandbox object. The configuration can
            instruct the sandbox to include fake timers, fake server, and how to
            interact with these. The default configuration looks like:
          </p>
          <pre class="sh_javascript"><code>sinon.defaultConfig = {
    // ...
    injectInto: null,
    properties: ["spy", "stub", "mock", "clock", "server", "requests"],
    useFakeTimers: true,
    useFakeServer: true
}</code></pre>
          <dl>
            <dt><code>injectInto</code></dt>
            <dd>
              The sandbox's methods can be injected into another object for
              convenience. The <code>injectInto</code> configuration option can
              name an object to add properties to. Usually, this is set by
              <code>sinon.test</code> such that it is the <code>this</code>
              value in a given test function.
            </dd>
            <dt><code>properties</code></dt>
            <dd>
              What properties to inject. Note that simply naming "server" here
              is not sufficient to have a <code>server</code> property show up
              in the target object, you also have to
              set <code>useFakeServer</code> to true.
            </dd>
            <dt><code>useFakeTimers</code></dt>
            <dd>
              If <code>true</code>, the sandbox will have a <code>clock</code>
              property. Can also be an array of timer properties to fake.
            </dd>
            <dt><code>useFakeServer</code></dt>
            <dd>
              <p>
                If <code>true</code>, <code>server</code> and
                <code>requests</code> properties are added to the sandbox. Can
                also be an object to use for fake server. The default one
                is <code>sinon.fakeServer</code>, but if you're using jQuery 1.3.x
                or some other library that does not set the XHR's
                <code>onreadystatechange</code> handler, you might want to do:
              </p>
              <pre class="sh_javascript"><code>sinon.config = {
    useFakeServer: sinon.fakeServerWithClock
};</code></pre>
            </dd>
          </dl>
        </dd>
        <dt><code>sandbox.spy();</code></dt>
        <dd>
          Works exactly like <code>sinon.spy</code>, only also adds the returned
          spy to the internal collection of fakes for easy restoring
          through <code>sandbox.restore()</code>.
        </dd>
        <dt><code>sandbox.stub();</code></dt>
        <dd>
          Works almost exactly like <code>sinon.stub</code>, only also adds the
          returned stub to the internal collection of fakes for easy restoring
          through <code>sandbox.restore()</code>. The sandbox <code>stub</code>
          method can also be used to stub any kind of property. This is useful
          if you need to override an object's property for the duration of a
          test, and have it restored when the test completes.
        </dd>
        <dt><code>sandbox.mock();</code></dt>
        <dd>
          Works exactly like <code>sinon.mock</code>, only also adds the returned
          mock to the internal collection of fakes for easy restoring
          through <code>sandbox.restore()</code>.
        </dd>
        <dt><code>sandbox.useFakeTimers();</code></dt>
        <dd>
          Fakes timers and binds the <code>clock</code> object to the sandbox
          such that it too is restored when
          calling <code>sandbox.restore()</code>.
          Access through <code>sandbox.clock</code>.
        </dd>
        <dt><code>sandbox.useFakeXMLHttpRequest();</code></dt>
        <dd>
          Fakes XHR and binds the resulting object to the sandbox such that it
          too is restored when calling <code>sandbox.restore()</code>. Access
          requests through <code>sandbox.requests</code>.
        </dd>
        <dt><code>sandbox.useFakeServer();</code></dt>
        <dd>
          Fakes XHR and binds a server object to the sandbox such that it
          too is restored when calling <code>sandbox.restore()</code>. Access
          requests through <code>sandbox.requests</code> and server through
          <code>sandbox.server</code>.
        </dd>
        <dt><code>sandbox.restore();</code></dt>
        <dd>Restores all fakes created through sandbox.</dd>
      </dl>
      <h3 id="sinon-test">Test methods</h3>
      <p>
        Wrapping test methods in <code>sinon.test</code> allows Sinon.JS to
        automatically create and manage sandboxes for you. The function's
        behavior can be configured through <code>sinon.config</code>.
      </p>
      <dl>
        <dt><code>var wrappedFn = sinon.test(fn);</code></dt>
        <dd>
          The <code>wrappedFn</code> function works exactly like the original
          one in all respect - in addition a sandbox object is created and
          automatically restored when the function finishes a call. By default
          the spy, stub and mock properties of the sandbox is bound to whatever
          object the function is run on, so you can do <code>this.spy()</code>
          (and stub, mock) and it works exactly like <code>sandbox.spy()</code>
          (and stub, mock), except you don't need to manually <code>restore()</code>.
        </dd>
      </dl>
      <h3>sinon.config</h3>
      <p>
        The configuration controls how Sinon binds properties when
        using <code>sinon.test</code>. The default configuration looks like:
      </p>
      <pre class="sh_javascript">{
    injectIntoThis: true,
    injectInto: null,
    properties: ["spy", "stub", "mock", "clock", "server", "requests"],
    useFakeTimers: true,
    useFakeServer: true
}</pre>
      <p>
        Simply set <code>sinon.config</code> to override any or all of these,
        e.g.:
      </p>
      <pre class="sh_javascript">sinon.config = {
    useFakeTimers: false,
    useFakeServer: false
}</pre>
      <p>
        In this case, defaults are used for the non-existent
        properties. Additionally, sandboxes and tests will not have automatic
        access to the fake timers and fake server when using this configuration.
      </p>
      <dl>
        <dt>Boolean <code>injectIntoThis</code></dt>
        <dd>
          Causes properties to be injected into the <code>this</code> object of
          the test function. Default <code>true</code>.
        </dd>
        <dt>Object <code>injectInto</code></dt>
        <dd>
          Object to bind properties to. If this is <code>null</code> (default)
          and <code>injectIntoThis</code> is <code>false</code> (not default),
          the properties are passed as arguments to the test function instead.
        </dd>
        <dt>Array <code>properties</code></dt>
        <dd>
          Properties to expose. Default is all:
          <code>["spy", "stub", "mock", "clock", "server",
          "requests"]</code>. However, the last three properties are only bound
          if the following two configuration options are <code>true</code>
          (which is the default).
        </dd>
        <dt>Boolean <code>useFakeTimers</code></dt>
        <dd>
          Causes timers to be faked and allows <code>clock</code> property to
          be exposed. Default is <code>true</code>.</dd>
        <dt>Boolean <code>useFakeServer</code></dt>
        <dd>
          Causes fake XHR and server to be created and allows
          <code>server</code> and <code>requests</code> properties to be
          exposed. Default is <code>true</code>.</dd>
      </dl>
      <h3 id="sinon-testCase">Test cases</h3>
      <p>
        If you need the behavior of <code>sinon.test</code> for more than one
        test method in a test case, you can use <code>sinon.testCase</code>,
        which behaves exactly like wrapping each test in <code>sinon.test</code>
        with one exception: <code>setUp</code> and <code>tearDown</code> can
        share fakes.
      </p>
      <dl>
        <dt><code>var obj = sinon.testCase({});</code></dt>
      </dl>
    </div>
    <div class="section" id="utils">
      <h2>Sinon.JS utilities</h2>
      <p>
        Sinon.JS has a few utilities used internally in lib/sinon.js. Unless the
        method in question is documented here, it should not be considered
        part of the public API, and thus is subject to change.
      </p>
      <dl>
        <dt><code>sinon.format(object)</code></dt>
        <dd>
          Formats an object for pretty printing in error messages. Sinon < 1.3.0
          defaulted to  coercing objects to strings. As of 1.3.0, Sinon uses
          <a href="https://busterjs.org/docs/buster-format/">buster-format</a>
          by default, or
          Node's <a href="http://nodejs.org/docs/v0.6.6/api/util.html">util</a>
          module. Feel free to override this method with your own implementation
          if you prefer different visualization of e.g. objects. The method
          should return a string.
        </dd>
        <dt><code>sinon.log(string)</code></dt>
        <dd>
          Logs internal errors, helpful for debugging. By default this property
          is a noop function, set it to something that prints warnings in your
          environment for more help, e.g. (if you are using JsTestDriver):
          <pre><code>sinon.log = function (message) {
    jstestdriver.console.log(message);
};</code></pre>
        </dd>
      </dl>
    </div>
    <div class="aside">
      <p>Sinon uses <a href="http://semver.org/">Semantic versioning</a>.</p>
      <p>
        Copyright 2010 - 2012,
        <a href="http://cjohansen.no/">Christian Johansen</a>. Released under the
        <a href="http://www.opensource.org/licenses/bsd-license.php">BSD license</a>.
      </p>
    </div>
    <script type="text/javascript" src="/design/js/sinon-web.min.js?4"></script>
  </body>
</html>
